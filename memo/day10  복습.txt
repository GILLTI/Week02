1. 메모리(RunTime Data Area) => JVM
	스택(Stack)
		메소드를 호출할 때마다 생성되는 프레임이 저장되는 영역
		프레임 내부에는 지역변수 스택이 있고 기본타입과 참조타입 변수가 생성되고 제거된다
	힙(Heap)
		객체, 배열이 생성되는 영역
		객체나 배열의 주소값은 메소드 영역과 스택영역의 상수와 변수에서 참조할 수 있다.
			
	메소드(Method)
		바이트 코드 파일을 읽은 내용이 저장되는 영역
		클래스별 상수, 정적필드, 메소드, 생성자 등이 저장된다

2. 클래스
	타입이다
	연관성이 잇는 여러개의 타입과 기능을 한곳에 모아서 편하게 관리할 수 있는 것
	객채를 생성하기 위한 특, 설계도면

3. 클래스를 구성하는 멤버
	class 클래스명 { 
		필드(멤버변수) : 객체의 데이터가 저장되는 곳
		메소드, 멤버메소드 : 객체가 수행할 동작(행위, 행동, 상태)
		생성자 : new 키워드로 객체를 생성할 때 객체의 초기화(객체의 필드) 역활을 담당	
	}

4. 객체화(인스턴스화)
	객체를 만드는 작업
	추상적인 개념(클래스)를 구체화시키는 작업
	
	클래스명 객체명 = new 생성자();

5. 생성자(Constructor)
	new 키워드로 객체를 생성할 때 객체의 초기화 역활을 담당
	
	syso(new Person());	//이 참조값과
	syso(new Person());	//이 참조값(저장공간주소)의 결과는 다르다

	Person p = new Person();
	syso(p);	// 같다

기본생성자와 매개변수가 있는 생성자
	public 클래스명(){}-----------> .num해서 초기화해준다
				>클래스명 객체명 = new 생성자();
					객체명.num = 10;

	Public 클래스명(int num){}		=> 클래스명 객체명 = new 생성자(10);

6. thus, this()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자
	
7.필드와 지역변수의 차이
	지역변수는 생성자와 메소드 블록에서 선언되고 생성자와 메소드 호출시에만 생성되고 사용된다
	필드는 클래스 블록에서 서언되고 객체 내부에서 존재하고 객체 내부, 외부에서 사용가능하다.

	구분 	필드			지역변수
	선언위치	클래스 선언 블록		생성자, 메소드 선언 블록
	존재위치	객체 내부에서 존재		생성자, 메소드 호출시에만 존재
	사용위치	객체 내,외부 어디든 사용	생성자, 메소드 블록 내부에서만 사용 

8. 메소드
-메소드 선언 
	리턴타입 메소드명(자료형 매개변수){
		실행할 문장;	
		return 리턴값;
	}

-메소드 호출
매개변수 	리턴값	호출방식
x	x	객체명.메소드명();
o	x	객체명.메소드명(인수);
x	o	syso(객체명.메소드명()); 리턴타입과 같은 자료형변수 = 객체명.메소드명();
o	o	syso(객체명.메소드명(인수)); 리턴타입과 같은 자료형변수 = 객체명.메소드명(인수);


-가변길이 매개변수
	리턴타입 메소드명(자료형 ... 매개변수명) {
		실행할문장;
		return 리턴값;
}

	메서드호출 : 매개변수 인수값을 쉼표로 구분해서 개수와 상관없이 사용가능